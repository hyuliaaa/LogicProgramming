:- discontiguous vertex/2.
in_union(X, A, B) :- (member(X, A); member(X, B)).
in_intersection(X, A, B) :- (member(X, A), member(X, B)).
in_difference(X, A, B) :- member(X, A), not(member(X, B)).



% X = {n : P(N)}
% findall(N, P(N), X) - намери всички n-o-ве, за к/о е изпълнено P(N) и ги запиши в X
% Условие за приложимост: P(N) генерира напълно известни стойности за N

% X = [1,3,4,5,8], findall(N, (member(N, X), N #= 2*K), Y). <-> за К имаме същестува К
% искаме да направим списък от неговите четни елементи, искаме всички n-owe, 
% За които е изпълнено условието да ги запишем в Y.


% Квантор за всеобщност
% forrall(P(X), Q(X, У)) за всички X-oве, за което е вярно P трябва да е вярно и Q :- not((P(X),not(q(X)))

% условие за приложимост: след изпълнение на P(X), стойността на X e напълно известна
% forall винаги слага квантори за съществуване

% всички елементи на даден списък са елементи на друг списък

% вярно ли е, че за всяко А, к/о е елемент на X e елемент и на Y

% 23 ?- X = [1,3,4,5], Y = [1,2,3,4,5,6], forall(member(A,X), member(A, Y)).
% X = [1, 3, 4, 5],      
% Y = [1, 2, 3, 4, 5, 6].

% 24 ?- X = [1,3,4,5, 7], Y = [1,2,3,4,5,6], forall(member(A,X), member(A, Y)).

% X = [1,3,4,5,7], forall(member(A,X), A #= 2*K). вярно ли е, че всички елементи на X са четни

prime(N) :-
    N#>= 2,
    forall((K #>= 2, K*K #<= N, label([K])), (N mod K #\= 0)).

% label([K])  получаване за K конкретна стойност. (уточняваме)
% след изпълнението на условието във втората част се уточняват всички променливи

% between(1,3, N) <-> N #>= 1, N #=< 3, label([N]).

% отрицание: not(p(x1,...xn))
% Условие: стойностите на X1... Xn са напълно известни.

% зад. 1 Да се дефинира на пролог предикат p(L),
% който по даден списък L от списъци
% проверява дали за всеки два елемента на L, 
% съществува трети елемент, съдържащ всички общи елементи на другите два


% 26 ?- X = [1,2,3,4], findall([A,B], (append(_, [A | Y], X), member(B, Y)), Z).
% X = [1, 2, 3, 4],
% Z = [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]].

p(L) :- forall(subset([X, Y], L),
               (member(Z, L), forall((member(A, X), member(A, Y)), member(A, Z)))).



% Да се дефинира на пролог предикат P(L, N), к/о по подадени списък от ест числа
% и ест. число N проверява, че има N елемента a1..an на L, такива че 
% за всеки N- 1 elementa б1...бn - 1 на L e изпълнено, че
% НОД(a1...an) \= НОД(b1...bn-1).

% N е делитетел на елементите на X
delitel(N, X) :- 
    member(B,X), N*L #= B, label([N]),
    forall(member(A,X), N*K #= A). % тоест N e делител на A.


% delitel(N, [6,3]).
% N = - 3
% N = - 1
% N = 1
% N = 3

% най-голям общ делител на списък
GCD(N, X) :-
    delitel(N, X),
    forall(delitel(M, X), M #=< N).

% зад.
% Казваме, че списък А от числа се поглъща от списък В от числа, 
% ако сборът на всеки два елемента на А се съдържа в В. Да се дефинират предикати
% pred(A, B), който по дадени списъци от числа A и В разпознава дали А се поглъща от В.
% q(L,S) - който по даден списък от списъци от числа генерира в S максимална
% (по дължниа) редица от различни елементи на L, за която е вярно, че всеки елемент на редицата
% се поглъща от всички елементи след него в S.

    
poglashta_se(X, Y) :-
    forall(subset([A,B], X), (N #= A + B, member(N, Y))).


% първо да направим, че в даден списък от списъци всеки се поглъща от следващите
vseki_se_poglyshta_ot_sledvashtiq(X) :-
forall(append(_, [A | Y], X)), % ако за произволно разцепване на Х на нещо си и [A | Y], 
% ще генерираме всички елементи А на X, a Y ще бъдат следващите елементи
          forall(member(B, Y), poglashta_se(A,B)).

% .................
% .................

% зад4. Редиците {an}, n= 0...n = inf И {bn}, n= 0...n = inf
% са зададени чрез а0 = 1, аn= 2an-1 + n и bn = 3bn-1 + n*2- 1.
% Да се дефинира предикат на пролог P(N), който генерира всички числа от вида:
% ai + bj

a(0, 1).
a(N, A) :- N #>0, N#= N - 1, a(N1, A1), A#=2*A1 + N.  % n-тият член на редициата от а-тата е А.

b(0, 1).
b(N, B):- N #> 0, N #= N - 1, b(N1, B1), B #= 3* B1 + N*N - 1.

nat(0).
nat(N) :- nat(K), N#= K + 1.

p4(N):-
    nat(K),
    I #> 0, J #>0,
    I #< K, J #< K, 
    a(I, AI), b(J, BJ), 
    N#= AI + BJ,
    label([N]).




% зад: Да се дефинира предикат на пролог p(L), к/о при преудовлетворяване
% генерира в L всички списъци от вида [X1, ....Xn], където Xi са списъци с 
% елементи ест. числа между 0 и 99 и за всяко i, Xi e префикс на Xi+1

% monotone_prefixes(X) - Х е списък от списъци, всеки от к/о е префикс на следващия
monotone_prefixes([]).
monotone_prefixes([_]).
monotone_prefixes([A, B | X]) :- append(A, _ ,B),% A e префикс на B
                                 monotone_prefixes([B | X]).

% p(L) - генерира всички списъци от списъци от ест. числа между 0 и 99,
% такива, че всеки елемент е префикс на следващия

% зад. Граф G без изолирани върхове ще представяме посредством 
% списък от всички двуелементни списъци [A, B], където в G има ребро от А до B.
% Да се дефинира на пролог предикат p(G), к/о по даден ориентиран граф G без изолирани
% втрхове да проверява дали върховете на G могат така да се оцветят в два цвята
% че никои 3 ребра да не образуват едноцветен триъгълник


vertex(G, V) :- member([V, _], G). % V e връх в такъв граф
vertex(G, V) :- member([_, V], G).

egde(G, U, V) :- member([U,V], G).

% Оцветен граф: X * Y (това не се смята може като ф(..) да се мисли), където:
% X е списък от двойки [V, C], където V е връх, а C e цвят.
% Y списък от ребра [U,V].

vertex(X*_, V):- member([V, _], X).
edge(_*Y, U, V) :- member([U,V], Y).

% цвят(G, V, C) - връх V на граф G има цвят С
color(X*_, V, C) :- member([V,C], X).

%искаме да получаваме списъци от всички върхове, ребра и цветова
verteces(G, VC) :- findall(V, vertex(G, V), VC).
edges(G, ES) :- findall([U,V], edge(G, U, V), ES).

% за цветовете не можем да използваме finall, понеже те още не са известни

%сдвояване(Х,У,Z) по дадени списъци Х и У с равн дължина намира списък Z
% н-тият елемент на Z e двойка А В, където А е н-тият елемент на Х,
% а В е н-тият елемент на У.

sdvoqvane([], [], []).
sdvoqvane([A | X], [B | Y], [[A, B] | Z]) :-sdvoqvane(X, Y, Z).

% sdvoqvane([1,2], [a,b], Z).
% Z =[[1,a], [2, b]].


colors(X*_, Colors) :- sdvoqvane().